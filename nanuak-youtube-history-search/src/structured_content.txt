=== file: src/main.rs
use color_eyre::Result;
use diesel::prelude::*;
use diesel::r2d2::ConnectionManager;
use diesel::r2d2::Pool;
use nanuak_config::config::NanuakConfig;
use nanuak_config::db_url::DatabasePassword;
use r2d2::PooledConnection;
use ratatui::DefaultTerminal;
use tracing::info;

// Bring in our modules:
mod app;
mod db;
mod ui;

use crate::app::App;

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;
    tracing_subscriber::fmt::init();

    let database_url = DatabasePassword::format_url(
        &NanuakConfig::acquire()
            .await?
            .get::<DatabasePassword>()
            .await?,
    );

    // Set up a database connection pool
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = Pool::builder().build(manager)?;
    let mut conn = pool.get()?;
    info!("Established database connection");

    // Initialize the terminal
    let mut terminal = ratatui::init();

    // Create the app, then run it
    let app = App::new(pool.clone(), &mut conn).await?;
    let result = app.run(&mut terminal, &mut conn).await;

    // Restore the terminal state
    ratatui::restore();

    result
}
=== file: src/app.rs
use color_eyre::Result;
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool, PooledConnection};
use eyre::WrapErr;
use ratatui::crossterm::event::{self, Event, KeyCode, KeyEventKind};
use ratatui::DefaultTerminal;

use nanuak_schema::youtube::videos;

use crate::db::{get_all_results, SearchResult};
use crate::ui;

pub struct App {
    pub search_term: String,
    pub results: Vec<SearchResult>,
    pub results_state: ratatui::widgets::ListState,
    pub pool: Pool<ConnectionManager<PgConnection>>,
}

impl App {
    pub async fn new(
        pool: Pool<ConnectionManager<PgConnection>>,
        conn: &mut PooledConnection<ConnectionManager<PgConnection>>,
    ) -> Result<Self> {
        let results = get_all_results(conn).await?;
        let mut results_state = ratatui::widgets::ListState::default();
        results_state.select(Some(0));

        Ok(Self {
            search_term: String::new(),
            results,
            results_state,
            pool,
        })
    }

    pub async fn update_search_results(&mut self, conn: &mut PgConnection) -> Result<()> {
        let pattern = format!("%{}%", self.search_term);

        let new_results = videos::table
            .select((videos::title, videos::video_id))
            .filter(videos::title.ilike(pattern))
            .load::<SearchResult>(conn)?;

        self.results = new_results;

        // Reset the selected index
        if self.results.is_empty() {
            self.results_state.select(None);
        } else {
            self.results_state.select(Some(0));
        }

        Ok(())
    }

    pub async fn run(
        mut self,
        terminal: &mut DefaultTerminal,
        conn: &mut PooledConnection<ConnectionManager<PgConnection>>,
    ) -> eyre::Result<()> {
        loop {
            terminal.draw(|f| ui::draw(f, &mut self))?;

            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Esc => break,

                    KeyCode::Char(c) => {
                        if key.kind == KeyEventKind::Press {
                            self.search_term.push(c);
                            self.update_search_results(conn).await?;
                        }
                    }

                    KeyCode::Backspace => {
                        if key.kind == KeyEventKind::Press && !self.search_term.is_empty() {
                            self.search_term.pop();
                            self.update_search_results(conn).await?;
                        }
                    }

                    KeyCode::Down => {
                        ui::select_next(&mut self.results_state, self.results.len());
                    }

                    KeyCode::Up => {
                        ui::select_previous(&mut self.results_state, self.results.len());
                    }

                    _ => {}
                }
            }
        }

        Ok(())
    }
}
=== file: src/db.rs
use color_eyre::Result;
use diesel::prelude::*;
use diesel::PgConnection;
use nanuak_schema::youtube::videos;

#[derive(Debug, Queryable)]
pub struct SearchResult {
    pub title: String,
    pub video_id: String,
}

pub async fn get_all_results(conn: &mut PgConnection) -> Result<Vec<SearchResult>> {
    let result = videos::table
        .select((videos::title, videos::video_id))
        .load::<SearchResult>(conn)?;

    Ok(result)
}
=== file: src/ui.rs
use ratatui::{
    layout::{Constraint, Direction, Layout},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph},
    Frame,
};

use crate::app::App;

pub fn draw(f: &mut Frame, app: &mut App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .margin(1)
        .constraints([Constraint::Length(3), Constraint::Min(0)].as_ref())
        .split(f.area());

    // Search box
    let search_block = Paragraph::new(format!("Search: {}", app.search_term))
        .block(Block::default().borders(Borders::ALL).title("Search"));
    f.render_widget(search_block, chunks[0]);

    // Results
    let results_block = Block::default().borders(Borders::ALL).title("Results");
    let items: Vec<ListItem> = app
        .results
        .iter()
        .map(|result| {
            ListItem::new(Line::from(vec![
                Span::styled(
                    &result.title,
                    Style::default()
                        .fg(Color::LightBlue)
                        .add_modifier(Modifier::BOLD),
                ),
                Span::raw(" "),
                Span::styled(
                    format!("(https://youtube.com/watch?v={})", result.video_id),
                    Style::default().fg(Color::Gray),
                ),
            ]))
        })
        .collect();

    let results_list = List::new(items)
        .block(results_block)
        .highlight_style(Style::default().add_modifier(Modifier::BOLD));
    f.render_stateful_widget(results_list, chunks[1], &mut app.results_state);
}

pub fn select_next(state: &mut ListState, len: usize) {
    if len == 0 {
        return;
    }
    let i = match state.selected() {
        Some(i) => {
            if i >= len - 1 {
                0
            } else {
                i + 1
            }
        }
        None => 0,
    };
    state.select(Some(i));
}

pub fn select_previous(state: &mut ListState, len: usize) {
    if len == 0 {
        return;
    }
    let i = match state.selected() {
        Some(i) => {
            if i == 0 {
                len - 1
            } else {
                i - 1
            }
        }
        None => 0,
    };
    state.select(Some(i));
}